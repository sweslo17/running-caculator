import React, { useState, useMemo } from 'react';

// --- Icon Component ---
const ChevronDown = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="h-5 w-5 transition-transform duration-300"><path d="m6 9 6 6 6-6"></path></svg>
);

// --- Utility Functions ---
const utils = {
    parseTimeToSeconds: (timeStr) => {
        if (!timeStr) return 0;
        const parts = timeStr.split(':').map(Number);
        if (parts.some(isNaN)) return 0;
        if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
        if (parts.length === 2) return parts[0] * 60 + parts[1];
        if (parts.length === 1) return parts[0];
        return 0;
    },
    formatTime: (seconds) => {
        if (seconds === null || isNaN(seconds) || seconds < 0) return "N/A";
        const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
        const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
        const s = Math.round(seconds % 60).toString().padStart(2, '0');
        return `${h}:${m}:${s}`;
    },
    formatPace: (secondsPerKm) => {
        if (secondsPerKm === null || isNaN(secondsPerKm) || secondsPerKm < 0 || !isFinite(secondsPerKm)) return "N/A";
        const m = Math.floor(secondsPerKm / 60).toString().padStart(2, '0');
        const s = Math.floor(secondsPerKm % 60).toString().padStart(2, '0');
        return `${m}:${s}`;
    },
    calculateVdot: (distance_meters, time_seconds) => {
        if (time_seconds <= 0) return null;
        const time_minutes = time_seconds / 60.0;
        const speed_mpm = (distance_meters / time_seconds) * 60.0;
        const percent_vo2max = 0.8 + 0.1894393 * Math.exp(-0.012778 * time_minutes) + 0.2989558 * Math.exp(-0.1932605 * time_minutes);
        const vo2_cost = -4.60 + 0.182258 * speed_mpm + 0.000104 * Math.pow(speed_mpm, 2);
        return vo2_cost / percent_vo2max;
    },
    getVdotTrainingPaces: (vdot_score) => {
        const vo2max_percentages = { "輕鬆跑 (E)": [0.59, 0.74], "馬拉松配速 (M)": [0.75, 0.84], "乳酸閾值配速 (T)": [0.83, 0.88], "間歇配速 (I)": [0.97, 1.00], "反覆跑配速 (R)": [1.05, 1.10] };
        const getSpeedFromVo2 = (target_vo2) => {
            const a = 0.000104, b = 0.182258, c = -4.60 - target_vo2;
            const discriminant = b * b - 4 * a * c;
            if (discriminant < 0) return null;
            return ((-b + Math.sqrt(discriminant)) / (2 * a)) / 60.0;
        };
        const paces = {};
        for (const [zone, [min_perc, max_perc]] of Object.entries(vo2max_percentages)) {
            const min_speed_mps = getSpeedFromVo2(min_perc * vdot_score);
            const max_speed_mps = getSpeedFromVo2(max_perc * vdot_score);
            if (min_speed_mps === null || max_speed_mps === null) { paces[zone] = "N/A"; continue; }
            paces[zone] = `${utils.formatPace(1000 / max_speed_mps)} - ${utils.formatPace(1000 / min_speed_mps)}`;
        }
        return paces;
    },
    getVdotEquivalentRaces: (vdot_score, tolerance = 0.05) => {
        const race_distances = { "1500公尺": 1500, "1英里": 1609.34, "3公里": 3000, "5公里": 5000, "10公里": 10000, "半程馬拉松": 21097.5, "全程馬拉松": 42195 };
        const equivalents = {};
        for (const [name, dist_m] of Object.entries(race_distances)) {
            let low = 1, high = dist_m * 10 * 60, best = null;
            for (let i = 0; i < 30; i++) {
                const mid = (low + high) / 2;
                if (mid <= 0) continue;
                const current_vdot = utils.calculateVdot(dist_m, mid);
                if (current_vdot === null) { high = mid; continue; }
                if (Math.abs(current_vdot - vdot_score) < tolerance) { best = mid; break; }
                else if (current_vdot > vdot_score) { low = mid; } 
                else { high = mid; }
            }
            if (best === null) {
                const vdot_low = utils.calculateVdot(dist_m, low);
                const vdot_high = utils.calculateVdot(dist_m, high);
                if (vdot_low === null || vdot_high === null) continue;
                best = Math.abs(vdot_low - vdot_score) < Math.abs(vdot_high - vdot_score) ? low : high;
            }
            equivalents[name] = utils.formatTime(best);
        }
        return equivalents;
    },
    calculateKValue: (t1_sec, d1_m, t2_sec, d2_m) => {
        if ([t1_sec, d1_m, t2_sec, d2_m].some(v => v <= 0) || d1_m === d2_m || t1_sec === t2_sec) return null;
        return Math.log(t2_sec / t1_sec) / Math.log(d2_m / d1_m);
    },
    riegelPrediction: (t1_sec, d1_m, d2_m, k) => {
        if ([t1_sec, d1_m, d2_m, k].some(v => v <= 0)) return null;
        return t1_sec * Math.pow(d2_m / d1_m, k);
    },
};

// --- Reusable Components ---
const InputGroup = ({ label, children }) => (
    <div className="flex flex-col">
        <label className="mb-1.5 text-sm font-medium text-slate-600">{label}</label>
        {children}
    </div>
);

const TheoryAccordion = ({ title, children }) => {
    const [isOpen, setIsOpen] = useState(false);
    return (
        <div className="border border-slate-200 rounded-lg mt-8">
            <button onClick={() => setIsOpen(!isOpen)} className="w-full flex justify-between items-center p-4 text-left font-semibold text-slate-700 bg-slate-50 hover:bg-slate-100 rounded-lg">
                <span>{title}</span>
                <span className={`transform ${isOpen ? 'rotate-180' : ''}`}><ChevronDown /></span>
            </button>
            {isOpen && <div className="p-6 bg-white border-t border-slate-200 rounded-b-lg prose prose-slate max-w-none">{children}</div>}
        </div>
    );
};

const ResultCard = ({ title, children }) => (
    <div className="bg-white p-6 rounded-xl shadow-md mt-6">
        <h3 className="text-lg font-semibold text-slate-800 mb-4">{title}</h3>
        {children}
    </div>
);

// --- Tab Content Components ---
const VdotCalculator = () => {
    const [distance, setDistance] = useState('5000');
    const [time, setTime] = useState('00:21:16');
    const [results, setResults] = useState(null);
    const raceDistances = { "1500公尺": 1500, "1英里": 1609.34, "3公里": 3000, "5公里": 5000, "10公里": 10000, "半程馬拉松": 21097.5, "全程馬拉松": 42195 };

    const handleSubmit = (e) => {
        e.preventDefault();
        const timeInSeconds = utils.parseTimeToSeconds(time);
        const distInMeters = parseFloat(distance);
        if (timeInSeconds > 0 && distInMeters > 0) {
            const vdot = utils.calculateVdot(distInMeters, timeInSeconds);
            if (vdot) {
                setResults({ vdot: vdot.toFixed(2), paces: utils.getVdotTrainingPaces(vdot), equivalents: utils.getVdotEquivalentRaces(vdot) });
            }
        } else {
            setResults(null);
        }
    };

    return (
        <div>
            <div className="bg-white p-6 rounded-xl shadow-md">
                <p className="text-slate-600 mb-4">輸入您近期一次全力以赴的比賽成績，來計算您的 VDOT 分數、等效成績與建議的訓練配速區間。</p>
                <form onSubmit={handleSubmit} className="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
                    <InputGroup label="比賽距離">
                        <select value={distance} onChange={e => setDistance(e.target.value)} className="w-full p-2 border border-slate-300 rounded-md focus:ring-2 focus:ring-indigo-500">
                            {Object.entries(raceDistances).map(([name, value]) => <option key={value} value={value}>{name}</option>)}
                        </select>
                    </InputGroup>
                    <InputGroup label="完賽時間 (HH:MM:SS)">
                        <input type="text" value={time} onChange={e => setTime(e.target.value)} className="w-full p-2 border border-slate-300 rounded-md focus:ring-2 focus:ring-indigo-500" placeholder="例如 00:21:16" />
                    </InputGroup>
                    <button type="submit" className="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-md hover:bg-indigo-700 h-10">計算 VDOT</button>
                </form>
            </div>
            {results && (
                <ResultCard title="VDOT 計算結果">
                    <div className="text-center bg-indigo-50 p-6 rounded-lg mb-6">
                        <p className="text-lg text-slate-600">您的 VDOT 分數</p>
                        <p className="text-5xl font-bold text-indigo-600 my-2">{results.vdot}</p>
                    </div>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <div>
                            <h4 className="font-semibold text-slate-700 mb-3">建議訓練配速 (分/公里)</h4>
                            <ul className="space-y-2">{Object.entries(results.paces).map(([zone, pace]) => <li key={zone} className="flex justify-between p-2 bg-slate-50 rounded-md"><span className="font-medium text-slate-600">{zone}</span><span className="font-mono text-slate-800">{pace}</span></li>)}</ul>
                        </div>
                        <div>
                            <h4 className="font-semibold text-slate-700 mb-3">等效比賽表現</h4>
                            <ul className="space-y-2">{Object.entries(results.equivalents).map(([race, time]) => <li key={race} className="flex justify-between p-2 bg-slate-50 rounded-md"><span className="font-medium text-slate-600">{race}</span><span className="font-mono text-slate-800">{time}</span></li>)}</ul>
                        </div>
                    </div>
                </ResultCard>
            )}
            <TheoryAccordion title="模型說明：Jack Daniels' VDOT 系統">
                <h4>VDOT 的定義</h4>
                <p>由 Jack Daniels 博士提出的 VDOT，被定義為「有效最大攝氧量」（effective VO2max）。它並非實驗室直接測量的最大攝氧量，而是一個基於比賽表現的分數，此分數將不同距離的跑步表現標準化，同時隱含地考慮了跑步經濟性與心理韌性等因素。</p>
                
                <h4>核心優勢</h4>
                <ul>
                    <li><strong>完整體系：</strong> VDOT 不僅僅是一個計算器，它是一個完整且自洽的訓練體系。它能將單一的比賽結果，轉化為一個具有明確生理目標的週期化訓練計畫。</li>
                    <li><strong>簡單易用：</strong> 只需要一次近期的比賽成績，就可以獲得所有等效成績和五個關鍵訓練區間的配速，為訓練提供了即時且可操作的起點。</li>
                    <li><strong>科學基礎：</strong> 每個訓練區間（E, M, T, I, R）都旨在系統性地針對特定的生理系統進行訓練，例如「I」配速針對最大攝氧量，「T」配速針對乳酸閾值。</li>
                </ul>

                <h4>主要限制</h4>
                <ul>
                    <li><strong>單一參數的盲點：</strong> VDOT 最大的限制在於其單一參數的本質。它假設了速度與耐力之間存在固定的關係，因此無法區分生理特徵可能截然不同的跑者。</li>
                    <li><strong>無法區分跑者類型：</strong> 一位擅長5公里的「速度型」跑者和一位擅長半馬的「耐力型」跑者，可能會得到完全相同的 VDOT 分數和訓練配速。這可能導致對速度型跑者的耐力訓練不足，同時忽略了耐力型跑者的速度需求。</li>
                </ul>
            </TheoryAccordion>
        </div>
    );
};

const RiegelCalculator = () => {
    const [kMode, setKMode] = useState('auto');
    const [race1, setRace1] = useState({ dist: '5000', time: '00:22:30' });
    const [race2, setRace2] = useState({ dist: '10000', time: '00:47:00' });
    const [manualK, setManualK] = useState('1.06');
    const [knownRace, setKnownRace] = useState({ dist: '5000', time: '00:22:30' });
    const [targetDist, setTargetDist] = useState('21097.5');
    const [results, setResults] = useState(null);

    const handleInputChange = (setter, field) => (e) => setter(prev => ({ ...prev, [field]: e.target.value }));

    const handleSubmit = (e) => {
        e.preventDefault();
        let kValue = kMode === 'auto' ? utils.calculateKValue(utils.parseTimeToSeconds(race1.time), parseFloat(race1.dist), utils.parseTimeToSeconds(race2.time), parseFloat(race2.dist)) : parseFloat(manualK);
        if (kValue === null || isNaN(kValue)) {
            setResults({ error: "無法計算 k 值，請檢查輸入的比賽成績是否有效且不重複。" });
            return;
        }
        const predictedTimeSec = utils.riegelPrediction(utils.parseTimeToSeconds(knownRace.time), parseFloat(knownRace.dist), parseFloat(targetDist), kValue);
        setResults({ kValue: kValue.toFixed(4), predictedTime: utils.formatTime(predictedTimeSec), error: null });
    };

    useMemo(() => { if (kMode === 'auto') setKnownRace(race1); }, [race1, kMode]);

    return (
        <div>
            <form onSubmit={handleSubmit} className="bg-white p-6 rounded-xl shadow-md space-y-6">
                <div>
                    <h3 className="text-lg font-semibold text-slate-800 mb-3">步驟一：決定您的疲勞因子 (k)</h3>
                    <div className="flex justify-center bg-slate-100 p-1 rounded-lg">
                        <button type="button" onClick={() => setKMode('auto')} className={`w-1/2 py-2 text-sm font-semibold rounded-md transition-colors ${kMode === 'auto' ? 'bg-indigo-600 text-white shadow' : 'text-slate-600'}`}>從比賽成績計算</button>
                        <button type="button" onClick={() => setKMode('manual')} className={`w-1/2 py-2 text-sm font-semibold rounded-md transition-colors ${kMode === 'manual' ? 'bg-indigo-600 text-white shadow' : 'text-slate-600'}`}>手動輸入</button>
                    </div>
                    {kMode === 'auto' ? (
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 pt-4">
                            <div className="space-y-3 p-4 bg-slate-50 rounded-lg border"><h4 className="font-medium text-slate-700">比賽成績 1</h4><InputGroup label="距離 (公尺)"><input type="number" value={race1.dist} onChange={handleInputChange(setRace1, 'dist')} className="w-full p-2 border rounded-md" /></InputGroup><InputGroup label="時間 (HH:MM:SS)"><input type="text" value={race1.time} onChange={handleInputChange(setRace1, 'time')} className="w-full p-2 border rounded-md" /></InputGroup></div>
                            <div className="space-y-3 p-4 bg-slate-50 rounded-lg border"><h4 className="font-medium text-slate-700">比賽成績 2</h4><InputGroup label="距離 (公尺)"><input type="number" value={race2.dist} onChange={handleInputChange(setRace2, 'dist')} className="w-full p-2 border rounded-md" /></InputGroup><InputGroup label="時間 (HH:MM:SS)"><input type="text" value={race2.time} onChange={handleInputChange(setRace2, 'time')} className="w-full p-2 border rounded-md" /></InputGroup></div>
                        </div>
                    ) : (
                        <div className="pt-4"><InputGroup label="手動輸入 k 值"><input type="number" step="0.001" value={manualK} onChange={(e) => setManualK(e.target.value)} className="w-full p-2 border rounded-md" /></InputGroup></div>
                    )}
                </div>
                <div>
                    <h3 className="text-lg font-semibold text-slate-800 mb-3">步驟二：預測比賽表現</h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div className="space-y-3"><h4 className="font-medium text-slate-700">基準成績</h4><InputGroup label="距離 (公尺)"><input type="number" value={knownRace.dist} onChange={handleInputChange(setKnownRace, 'dist')} disabled={kMode === 'auto'} className="w-full p-2 border rounded-md disabled:bg-slate-100" /></InputGroup><InputGroup label="時間 (HH:MM:SS)"><input type="text" value={knownRace.time} onChange={handleInputChange(setKnownRace, 'time')} disabled={kMode === 'auto'} className="w-full p-2 border rounded-md disabled:bg-slate-100" /></InputGroup></div>
                        <div className="space-y-3"><h4 className="font-medium text-slate-700">預測目標</h4><InputGroup label="目標距離 (公尺)"><input type="number" value={targetDist} onChange={(e) => setTargetDist(e.target.value)} className="w-full p-2 border rounded-md" /></InputGroup></div>
                    </div>
                </div>
                <button type="submit" className="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-md hover:bg-indigo-700">計算與預測</button>
            </form>
            {results && (
                <ResultCard title="Riegel 計算結果">
                    {results.error ? <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-md"><p>{results.error}</p></div> : (
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-center">
                            <div className="bg-indigo-50 p-4 rounded-lg"><p className="text-lg text-slate-600">您的個人化 k 值</p><p className="text-4xl font-bold text-indigo-600 my-1">{results.kValue}</p></div>
                            <div className="bg-green-50 p-4 rounded-lg"><p className="text-lg text-slate-600">目標距離預測時間</p><p className="text-4xl font-bold text-green-700 my-1 font-mono">{results.predictedTime}</p></div>
                        </div>
                    )}
                </ResultCard>
            )}
            <TheoryAccordion title="模型說明：Riegel 疲勞因子 (k)">
                <h4>模型與創立者</h4>
                <p>此模型由研究工程師 <strong>Peter Riegel</strong> 於1970年代末至1980年代初開發。其核心是一個簡潔的冪次定律方程式，推導自一項經驗觀察：對於世界紀錄的表現，將平均速度的對數與距離的對數進行繪圖，會形成一條近乎完美的直線。</p>

                <h4>深入解析疲勞因子 (k)</h4>
                <p>疲勞因子 <code>k</code> 是 Riegel 模型的靈魂，它用一個數值量化了**隨著比賽距離增加，跑者速度衰退的程度**。一個較高的 <code>k</code> 值意味著速度衰退得更快，而一個較低的 <code>k</code> 值則代表您有著絕佳的耐力。</p>
                <ul>
                    <li><strong>高 k 值 (例如 {'>'} 1.08)</strong>：代表您可能更偏向「速度型」跑者。您在短距離上速度飛快，但抗疲勞能力相對較弱，長距離的表現衰退會比較明顯。</li>
                    <li><strong>低 k 值 (例如 {'<'} 1.05)</strong>：代表您是「耐力猛獸」。您非常能抵抗疲勞，即使距離拉長，也能很好地維持配速。</li>
                    <li><strong>標準值 k ≈ 1.06</strong>：這是 Riegel 根據世界頂級運動員數據得出的平均值。如果您的 k 值接近此數值，表示您的速度與耐力發展相對均衡。</li>
                </ul>
                
                <h4>核心優勢</h4>
                <ul>
                    <li><strong>極度簡潔：</strong> 公式的概念非常簡單直觀，容易理解與計算。</li>
                    <li><strong>個人化診斷工具：</strong> 與其使用固定的 <code>k</code> 值，不如將其視為一個可訓練的、個人化的生理變數。透過計算個人專屬的 <code>k</code> 值，您可以有效地衡量自己的抗疲勞能力是否在一個訓練週期內有所進步。</li>
                </ul>

                <h4>主要限制</h4>
                <ul>
                    <li><strong>「一體適用」的缺陷：</strong> 標準的 <code>k=1.06</code> 是根據世界頂級運動員的數據推導出來的，未能考慮到個體間的生理差異，因此對普通跑者的預測可能不準確。</li>
                    <li><strong>馬拉松預測不準：</strong> 多項研究表明，Riegel 模型會**顯著低估**業餘跑者的全程馬拉松完賽時間，因為它無法完全反映馬拉松所需的專項耐力。</li>
                    <li><strong>單點故障風險：</strong> 模型完全依賴輸入的比賽表現，使其極易受到比賽當天狀況的影響。一場狀況不佳的比賽會得出過於悲觀的預測。</li>
                </ul>

                <h4>如何精確計算 k 值？</h4>
                <p>要計算個人化的 <code>k</code> 值，您需要至少兩次近期、全力以赴的不同距離比賽成績。公式為：<code>k = ln(T2 / T1) / ln(D2 / D1)</code>，其中 T 是時間，D 是距離，ln 是自然對數。</p>
            </TheoryAccordion>
        </div>
    );
};

// --- Main App Component ---
export default function App() {
    const [activeTab, setActiveTab] = useState('vdot');
    const tabs = { 'vdot': { name: 'VDOT 系統計算機', component: <VdotCalculator /> }, 'riegel': { name: 'Riegel 模型分析工具', component: <RiegelCalculator /> } };

    return (
        <div className="bg-slate-100 min-h-screen font-sans text-slate-800">
            <div className="container mx-auto p-4 md:p-8 max-w-4xl">
                <header className="text-center mb-8">
                    <h1 className="text-4xl font-bold text-slate-900">跑步表現計算機</h1>
                    <p className="text-lg text-slate-600 mt-2">VDOT 系統與 Riegel 模型分析與預測</p>
                </header>
                <div className="flex justify-center border-b border-slate-300 mb-8">
                    {Object.keys(tabs).map(tabKey => (
                        <button key={tabKey} onClick={() => setActiveTab(tabKey)} className={`px-4 py-3 font-semibold text-sm md:text-base transition-colors duration-300 ${activeTab === tabKey ? 'border-b-2 border-indigo-600 text-indigo-600' : 'text-slate-500 hover:text-indigo-500'}`}>
                            {tabs[tabKey].name}
                        </button>
                    ))}
                </div>
                <main>{tabs[activeTab].component}</main>
                <footer className="text-center mt-12 text-sm text-slate-500">
                    <p>此工具僅供參考，所有計算均基於公開的學術模型。訓練計畫應諮詢專業教練。</p>
                </footer>
            </div>
        </div>
    );
}

